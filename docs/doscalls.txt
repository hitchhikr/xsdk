------------------------------------------------------------------

           Resources for assembler programmers

                        #$03

              <DOS Call Simple Reference>

                   by Makoto Kamata

        Translated and curated by Franck Charlet

------------------------------------------------------------------


This time, we provide a quick reference for all DOS calls (including unpublished ones) provided by Human68k version 3.02.

In particular, the unpublished parts have been analyzed and summarized by the author, 
so please do not contact Sharp or Hudson.

The call names of unpublished DOS calls have been chosen to match existing names as much as possible,
but there are also a few that have been arbitrarily named by the author.

This material is provided without warranty.


References
------------------------------------------------------------------
Number Call Name Function Overview
<Input data
>Output data
supplementary explanation
------------------------------------------------------------------
$FF00 _EXIT         Process termination (no exit code specified)

No parameters

No return

Closes all handlers that the current process has open.

Frees all memory blocks used by the current process.

Transfers process management to the parent process.

Restore the stack pointer as PSP($40).l>SSP, PSP($3C).l>USP.

Restores _EXITVC, _CTRLVC, _ERRJVC and TRAP#10 to #14 according to the process management table of the parent process.

Closes the Kana-Kanji conversion line.

Sets the exit code to 0.

Returns the DOS call level to 0.

PSP($14).l > PC, PSP($44).w > SR and jump to immediately after _EXEC of the parent process.
------------------------------------------------------------------
$FF01 _GETCHAR      Read one byte from standard input (echoed back to standard output)

No parameters

>D0.l:One byte of input data

The input data is echoed back to standard output.
------------------------------------------------------------------
$FF02 _PUTCHAR      Output one byte to standard output

<(SP).w:One byte of data

>D0.l:0
------------------------------------------------------------------
$FF03 _COMINP       Read one byte from standard serial I/O

No parameters

>D0.l:One byte of input data
------------------------------------------------------------------
$FF04 _COMOUT       Output one byte to standard serial I/O

<(SP).w:One byte of data

>D0.l:Number of bytes output
------------------------------------------------------------------
$FF05 _PRNOUT       Output one byte to the standard printer output

<(SP).w:One byte of data

>D0.l:Number of bytes output
------------------------------------------------------------------
$FF06 _INPOUT       Standard I/O handler input/output

<(SP).w:One byte of data

        $FE     Read ahead from standard input (returns even if it is 0, BREAK check is enabled)
        $FF     Input from standard input (returns even if 0, BREAK check enabled)
        Other   Output one byte to standard output

>D0.l:One byte of input data
------------------------------------------------------------------
$FF07 _INKEY        Read one byte from standard input (does not process ^C, ^P, ^N)

No parameters

>D0.l:One byte of input data
------------------------------------------------------------------
$FF08 _GETC         Read one byte from standard input (processes ^C, ^P, ^N)

No parameters

>D0.l:One byte of input data
------------------------------------------------------------------
$FF09 _PRINT        Output a string to standard output

<(SP).l:String address

>D0.l:0

The _PRINT output is processed byte by byte.

Since a BREAK check and other checks are performed every time a byte is output, 
it becomes very slow, especially when redirecting.

When outputting a large amount of data, you can output faster by using _FPUTS or _WRITE.
HIOCS.X hooks _PRINT, and if the output destination is not redirected, 
it displays all the text at once, speeding up the text display.

This is why text display is dramatically faster when HIOCS.X is installed.
------------------------------------------------------------------
$FF0A _GETS         Read a string from standard input (processes ^C, ^P, ^N)

<(SP).l:Buffer

        0000    .b  Maximum number of input bytes
        0001    .b  Actual number of bytes entered
        0002        Input buffer (maximum number of input bytes + One byte required)

>D0.l:Number of bytes entered
------------------------------------------------------------------
$FF0B _KEYSNS       Read one byte ahead from standard input

No parameters

>D0.l:One byte of input data

Not console input.
------------------------------------------------------------------
$FF0C _KFLUSH       Flush the standard input buffer and then read from standard input.

<(SP).w:Mode

        1   _GETCHAR    Read one byte from standard input (echoed back to standard output)

            >D0.l:One byte of input data

        6   _INPOUT     Standard I/O handler input/output

            <2(SP).w:One byte of data

                $FE     Read ahead from standard input (returns even if it is 0, BREAK check is enabled)
                $FF     Input from standard input (returns even if 0, BREAK check enabled)
                Other   Output one byte to standard output

            >D0.l:One byte of input data

        7   _INKEY      Read one byte from standard input (does not process ^C, ^P, ^N)

            >D0.l:One byte of input data

        8   _GETC       Read one byte from standard input (processes ^C, ^P, ^N)

            >D0.l:One byte of input data

        10  _GETS       Read a string from standard input (processes ^C, ^P, ^N)

            <2(SP).l:Buffer

                0000    .b  Maximum number of input bytes
                0001    .b  The worksheet that contains the actual number of bytes entered
                0002        Input buffer (maximum number of input bytes + One byte required)

            >D0.l:Number of bytes entered

        Other   Flush only

            >D0.l:0

Not console input.
------------------------------------------------------------------
$FF0D _FFLUSH       Buffer Flush

No parameters

>D0.l:0

Issues a buffer flush to the buffer management routine.

If any drives use special device drivers, issue the fflush command for all of them.

_FFLUSH can be disabled with _FFLUSMD.
------------------------------------------------------------------
$FF0E _CHGDRV       Change the current drive

<(SP).w:Drive number (0=A:)

>D0.l:The maximum drive number that can be set (1=A:)
------------------------------------------------------------------
$FF0F _DRVCTRL      Drive control

<(SP).b:Mode

<1(SP).b:Drive number (0 = current drive, 1 = A:)

        Mode

            0   Get the drive status

            1   Eject

                Error when there are open files on the specified drive.
                Buffers related to the specified drive are flushed.
                Initialize FAT search for the specified drive.

            2   Eject prohibition

                Also disable ejection in mode 1

            3   Eject permission

                The buffers associated with the specified drive are flushed.

            4   LED flashes when no disc is inserted

            5   The LED turns off when no disc is inserted.

            9   Eject

                Same as 1

            10  Initialize FAT search only

                Initialize FAT search for the specified drive

            16 and over 

                Get the drive status

            Other
                    Error

>D0.l:Drive status

        bit 0   Incorrect insertion
        bit 1   Media insertion
        bit 2   Not ready
        bit 3   Write protect
        bit 4   Eject prohibited by user
        bit 5   Buffer exists
        bit 6   Eject prohibited
        bit 7   LED flashing
------------------------------------------------------------------
$FF10 _CONSNS       Check whether output to standard output is possible

No parameters

>D0.l:0 = Not possible, Other = Possible
------------------------------------------------------------------
$FF11 _PRNSNS       Check whether output to a standard printer is possible

No parameters

>D0.l:0 = Not possible, Other = Possible
------------------------------------------------------------------
$FF12 _CINSNS       Check whether input from standard serial I/O is possible

No parameters

>D0.l:0 = Not possible, Other = Possible
------------------------------------------------------------------
$FF13 _COUTSNS      Check whether output to standard serial input/output is possible

No parameters

>D0.l:0 = Not possible, Other = Possible
------------------------------------------------------------------
$FF17 _FATCHK       Check the FAT connections of files and directories

<(SP).l:File name
<4(SP).l:Top of the buffer

        bit 31 = 0

            0000    .w  Drive number (0=A:)
            0002    .w  First sector number
            0004    .w  Number of sectors
             :      Start sector number = 0 and end

        bit 31 = 1

            0000    .w  Drive number (0=A:)
            0002    .l  First sector number
            0006    .l  Number of sectors
             :      Start sector number = 0 and end
            <8(SP).w:Buffer size

>D0.l:Number of bytes used in the buffer
------------------------------------------------------------------
$FF18 _HENDSP       Kana-Kanji conversion window control

<(SP).w:Mode
        0   Open the status window
        
            >D0.l:Status window width

        1   Write normally in the status window

            <2(SP).w:Display start position offset
            <4(SP).l:String

            >D0.l:Next position offset

        2   Write in reverse in the status window

            <2(SP).w:Display start position offset
            <4(SP).l:String

            >D0.l:Next position offset

        3   Close the status window

        4   Open an input window

            >D0.l:Input window width

        5   Write normally in the input window

            <2(SP).w:Display start position offset
            <4(SP).l:String

            >D0.l:Next position offset

        6   Write in reverse in the input window

            <2(SP).w:Display start position offset
            <4(SP).l:String

            >D0.l:Next position offset

        7   Closes the input window (restores the specified position and subsequent entries)

            <2(SP).w:Remaining width

        8   Open the candidates window

            >D0.l:Candidate window width

        9   Write normally in the candidate window
        
            <2(SP).w:Display start position offset
            <4(SP).l:String

            >D0.l:Next position offset

        10  Write in reverse in the candidate window

            <2(SP).w:Display start position offset
            <4(SP).l:String

            >D0.l:Next position offset

        11  Close the candidate window
------------------------------------------------------------------
$FF19 _CURDRV       Get the current drive number

No parameters

>D0.l:Current drive number (0=A:)
------------------------------------------------------------------
$FF1A _GETSS        Read a string from standard input (does not process ^C, ^P, ^N)

<(SP).l:Buffer

        0000    .b  Maximum number of input bytes
        0001    .b  The worksheet that contains the actual number of bytes entered
        0002        Input buffer (maximum number of input bytes + One byte required)

>D0.l:Number of bytes entered
------------------------------------------------------------------
$FF1B _FGETC        Read one byte from the specified handler

No parameters

>D0.l:One byte of input data
------------------------------------------------------------------
$FF1C _FGETS        Read a string from the specified handler

<(SP).l:Buffer

        0000    .b  Maximum number of input bytes
        0001    .b  The worksheet that contains the actual number of bytes entered
        0002        Input buffer (maximum number of input bytes + One byte required)

<4(SP).w:Handler number

>D0.l:Number of bytes entered
------------------------------------------------------------------
$FF1D _FPUTC        Output one byte to the specified handler

<(SP).w:One byte of data
<2(SP).w:Handler number

>D0.l:Error code
------------------------------------------------------------------
$FF1E _FPUTS        Output a string to the specified handler

<(SP).l:String address
<4(SP).w:Handler number

>D0.l:Error code
------------------------------------------------------------------
$FF1F _ALLCLOSE     Close all handlers opened by the running process and its child processes

No parameters

No return value
------------------------------------------------------------------
$FF20 _SUPER        Switch between processor modes

<(SP).l:Original SSP value (0 when switching to supervisor mode)

>D0.l:Original SSP value

        $FFFFFFE6   Already in supervisor mode

Transition from user mode to supervisor mode or from supervisor mode to user mode
------------------------------------------------------------------
$FF21 _FNCKEY       Read and set redefinable keys

<(SP).b:Mode (0 = read, other = setting)
<1(SP).b:Number (0=all, 1-32)

        0   All
        1   F1
        2   F2
        3   F3
        4   F4
        5   F5
        6   F6
        7   F7
        8   F8
        9   F9
        10  F10
        11  SHIFT+F1
        12  SHIFT+F2
        13  SHIFT+F3
        14  SHIFT+F4
        15  SHIFT+F5
        16  SHIFT+F6
        17  SHIFT+F7
        18  SHIFT+F8
        19  SHIFT+F9
        20  SHIFT+F10
        21  ROLL UP
        22  ROLL DOWN
        23  INS
        24  DEL
        25  UP
        26  LEFT
        27  RIGHT
        28  DOWN
        29  CLR
        30  HELP
        31  HOME
        32  UNDO

<2(SP).l:Buffer

>D0.l:0 = Normal completion, -1 = Error (number is invalid)

The buffer size is 32 bytes for numbers 1-20, and 6 bytes for numbers 21-32, for a total of 712 bytes.

When the redefinable key setting is set to a number between 1 and 20,
if the beginning of the buffer is $FE, the first 7 bytes are considered to be the string to be displayed,
and the 9th byte and onwards are the string to be actually entered.

When the redefinable key setting is 1-20, the Kana-Kanji conversion line is closed
and the redefinable key is displayed again.
------------------------------------------------------------------
$FF22 _KNJCTRL      Kana-Kanji conversion control

Undefined by default.
It is defined by incorporating ASK68K.SYS etc.
------------------------------------------------------------------
$FF23 _CONCTRL      Console output control

<(SP).w:Mode

        0   Display one character of text

            <2(SP).w:Character code (JIS code accepted)

                When $01xx is specified, the control code is ignored and displayed for the lower byte.

            >D0.l:X and Y coordinates of the text cursor after display

                Lo word: Y coordinate
                Hi word: X coordinate

        1   Text string Display

            <2(SP).l:String address

            >D0.l:X and Y coordinates of the text cursor after display

                Lo word: Y coordinate
                Hi word: X coordinate

        2   Get or set text color code

            <2(SP).w:Text color code (0-15)

                -1  Retrieval only
                0   Black
                1   Blue
                2   Yellow
                3   White
                4   Black
                5   Blue, Bold
                6   Yellow, Bold
                7   White, Bold
                8   Black
                9   Blue, Reverse
                10  Yellow, Reverse
                11  White, Reverse
                12  Black
                13  Blue, Bold, Reverse
                14  Yellow, Bold, Reverse
                15  White, Bold, Reverse
            
            >D0.l:Text color code before change

                -1      Error (Text color code is incorrect)
                Other   Text color code before change (0-15)
            
            Specifies the color of the next character to be displayed on the text screen.
            The text color is affected by _TPALET and _TCOLOR.

        3   Get or set text cursor position

            <2(SP).w:Text cursor X coordinate

                -1  Retrieval only

            <4(SP).w:Text cursor Y coordinate

            >D0.l:Text cursor X and Y coordinates before change

                -1  Error (Text cursor X or Y coordinate is outside the text range)
                Lo word: Y coordinate
                Hi word: X coordinate

        4   Move the text cursor down one line (scroll if unable to move)

            >D0.l:0

            When the cursor is at the bottom of the text display range,
            the text screen scrolls up one line without moving the cursor,
            and the bottom line is filled with the text background color.

        5   Move the text cursor up one line (scroll if unable to move)

            >D0.l:0

            When the cursor is at the top of the text display range,
            the text screen scrolls down one line without moving the cursor,
            and the top line is filled with the text background color.

        6   Move the text cursor up n lines (error if unable to move)

            <2(SP).w:Number of lines to move (1 line if 0)

            >D0.l:Error code

                0   Normal termination
                -1  Can't move

        7   Move the text cursor down n lines (if unable to move, stops at the bottom line)

            <2(SP).w:Number of lines to move (1 line if 0)

            >D0.l:0

        8   Move the text cursor n columns to the right (if it cannot be moved, it will stop at the right edge)

            <2(SP).w:Number of digits to move (1 digit if 0)

            >D0.l:0

        9   Move the text cursor n columns to the left (if it cannot be moved, it will stop at the left edge)

            <2(SP).w:Number of digits to move (1 digit if 0)

            >D0.l:0

        10  Clear text screen (select range to clear)

            <2(SP).w:Clear range

                0   From the cursor position to the bottom right edge
                1   From the left end of the top line to the cursor position
                2   From the left end of the top row to the right end of the bottom row

            >D0.l:Error code

                0   Normal termination
                -1  The parameters are incorrect

            Fills the specified area of the text screen with the text background color.

        11  Clear text line (select range to clear)

            <2(SP).w:Clear range

                0   From the cursor position to the right edge
                1   From the left edge to the cursor position
                2   From left to right

            >D0.l:Error code

                0   Normal termination
                -1  The parameters are incorrect

            Fills the specified range of the cursor line on the text screen with the text background color.

        12  Insert n blank lines below the text cursor line

            <2(SP).w:Number of rows to insert (1 row if 0)

            >D0.l:Text cursor X coordinate

            The inserted blank line will be filled with the text background color.
            The lines that were originally below the cursor line will be moved down the specified number of lines.

        13  Delete n lines from the text cursor line

            <2(SP).w:Number of lines to delete (1 line if 0)

            >D0.l:Text cursor X coordinate

            Any lines below the deleted range will be moved up the specified number of lines.
            The specified number of blank lines will be created at the bottom of the text display area.
            The blank lines will be filled with the text background color.

        14  Get or set redefinable key display mode

            <2(SP).w:Mode

                -1  Acquisition
                0   Normal
                1   Shift
                2   Do not display
                3   Normal line

            >D0.l:Mode before setting

        15  Set the scroll range

            <2(SP).w:The Y coordinate of the starting row of the scroll range
            <4(SP).w:Number of lines in the scroll range

            >D0.l:0 = Normal completion, -1 = Error (number of rows out of range)

            The number of lines is limited by the display mode of the redefinable keys.

        16  Set the screen Mode

            <2(SP).w:Screen mode

                0   768x512,No graphics
                1   768x512,16-color graphics
                2   512x512,No graphics
                3   512x512,16-color graphics
                4   512x512,256-color graphics
                5   512x512,65536-color graphics

            >D0.l:Screen mode before setting

            The Kana-Kanji conversion line is closed.
            The display mode of redefinable keys remains unchanged.

        17  Show the text cursor

            No return value
                
        18  Hide text cursor

            No return value
------------------------------------------------------------------
$FF24 _KEYCTRL      Console input control
<(SP).w:Mode

        0   Enter one character from the keyboard

            >D0.l:One byte of input data

        1   One character sense from the keyboard

            >D0.l:Sensed one byte data

        2   Get the shift key and LED status

            >D0.l:Shift key and LED status

                Each bit is 0 = released, 1 = pressed

                    bit 0   SHIFT
                    bit 1   CTRL
                    bit 2   OPT.1
                    bit 3   OPT.2

                Each bit 0 = off, 1 = on

                    bit 4   Kana
                    bit 5   Roman letters
                    bit 6   Enter the code
                    bit 7   CAPS
                    bit 8   INS
                    bit 9   Hiragana
                    bit 10  Full-width

        3   Get key press status

            <2(SP).w:Scancode Group

            >D0.l:Key press status (each bit 0 = released, 1 = pressed)

                Group   bit 7   bit 6   bit 5   bit 4   bit 3   bit 2   bit 1   bit 0

                $0000   6&      5%      4$      3#      2"      1!      ESC     None
                $0001   BS      \|      ^~      -=      0       9)      8(      7'
                $0002   U       Y       T       R       E       W       Q       TAB
                $0003   S       A       CR      [{      @`      P       O       I
                $0004   ;+      L       K       J       H       G       F       D
                $0005   N       B       V       C       X       Z       ]}      :*
                $0006   DEL     HOME    SP      _       /?      .>      ,<      M
                $0007   CLR     DOWN    RIGHT   UP      LEFT    UNDO    R.DOWN  R.UP
                $0008   4       +       9       8       7       -       *       /
                $0009   0       ENTER   3       2       1       =       6       5
                $000A   XF3     XF2     XF1     HELP    Reg     Symb    .       ,
                $000B   Hira    INS     CAPS    Code    Rome    Kana    XF5     XF4
                $000C   F5      F4      F3      F2      F1      COPY    BREAK   Full-width
                $000D   None    None    None    F10     F9      F8      F7      F6
                $000E   None    None    None    NUM     OPT.2   OPT.1   CTRL    SHIFT
                $000F   None    None    None    None    None    None    None    None

        4   Set INS key mode

            <2(SP).w:INS key mode (0=OFF, 1=ON)

            >D0.l:0
------------------------------------------------------------------
$FF25 _INTVCS       Set an exception handling vector
<(SP).w:Vector number

        $0002-$00FF Interrupt vector
        $0100-$01FF IOCS call
        $FF00-$FFFF DOS calls, etc.

<2(SP).l:Vector

>D0.l:Original vector

The following vector settings are reflected in the process control table for the current process:

        _EXITVC
        _CTRLVC
        _ERRJVC
        TRAP #10
        TRAP #11
        TRAP #12
        TRAP #13
        TRAP #14

Depending on the settings of _CTRLVC and _ERRJVC, the SR and SSP values at the time of setting will be reflected 
in the sr and ssp at the time of abort in the process management table of the current process.

Please note that the USP will not be saved.

The setting of _CTRLVC also sets _ERRJVC.

Therefore, if you set different routines for _CTRLVC and _ERRJVC, you must set _ERRJVC last.
------------------------------------------------------------------
$FF26 _PSPSET       Create a process management table

<(SP).l:The starting address of the memory block where the process management table is created

>D0.l:0

A new process management table is created and process management is migrated to that process management table.

The PC at the time of creation is stored in _EXITVC, so _EXIT allows you to return immediately after _PSPSET.
------------------------------------------------------------------
$FF27 _GETTIM2      Get the time (long word)

No parameters

>D0.l:Time ((hour<<16)+(minute<<8)+seconds)

        00000000_hhhhhhhh_mmmmmmmm_ssssssss

            h   Hour (0-23)
            m   Minutes (0-59)
            s   Seconds (0-59)

It is accurate to the second.
------------------------------------------------------------------
$FF28 _SETTIM2      Set the time (long word)

<(SP).l:Time ((hour<<16)+(minute<<8)+seconds)

        00000000_hhhhhhhh_mmmmmmmm_ssssssss

            h   Hour (0-23)
            m   Minutes (0-59)
            s   Seconds (0-59)

>D0.l:Error code

It can be set accurately down to the second.
------------------------------------------------------------------
$FF29 _NAMESTS      Filename decomposition

<(SP).l:File name

<4(SP).l:Buffer (88 bytes)

        0000    .b  Flags

            $FF     No file specified
            $00     No wildcards
            Other   Wildcards available

        0001    .b      Drive number (0=A:)
        0002    .b[65]  Path (separated by '\')
        0043    .b[8]   Filename 1
        004B    .b[3]   Extension
        004E    .b[10]  File name 2

        (88 bytes)

>D0.l:Error code

Break down and organize file names.
------------------------------------------------------------------
$FF2A _GETDATE      Get the date

>D0.l:Date((Day of week (0=day)<<16)+((Year-1980)<<9)+(Month<<5)+Day)

        00000000_00000www_yyyyyyym_mmmddddd

            w   Day of the week (0-6)
            y   Year-1980(0-99)
            m   Month (1-12)
            d   Day (1-31)
------------------------------------------------------------------
$FF2B _SETDATE      Set the date

<(SP).l:Date(((year-1980)<<9)+(month<<5)+day)

        yyyyyyym_mmmddddd

            y   Year-1980(0-99)
            m   Month (1-12)
            d   Day (1-31)

>D0.l:Error code
------------------------------------------------------------------
$FF2C _GETTIME      Get the time (word)

>D0.l:Time ((hour<<11)+(minute<<5)+(second/2))

        hhhhhmmm_mmmsssss

            h   Hour (0-23)
            m   Minutes (0-59)
            s   Seconds/2(0-29)

Seconds are in 2-second increments.
------------------------------------------------------------------
$FF2D _SETTIME      Set the time (word)

<(SP).w:Time ((hour<<11)+(minute<<5)+(second/2))

        hhhhhmmm_mmmsssss

            h   Hour (0-23)
            m   Minutes (0-59)
            s   Seconds/2(0-29)

>D0.l:Error code

Seconds are in 2-second increments.
------------------------------------------------------------------
$FF2E _VERIFY       Set verify mode

<(SP).w:Verify mode (0=OFF, 1=ON)

No return value
------------------------------------------------------------------
$FF2F _DUP0         Convert a standard handler

<(SP).w:Destination handler number (0-4)
<2(SP).w:Handler number of the source (0-4)

>D0.l:Previous destination handler number (0-4)

Used to set CTTY when switching the console to standard serial I/O.
------------------------------------------------------------------
$FF30 _VERNUM       Get Human version

>D0.l:Human version (('68'<<16)+$0302)
------------------------------------------------------------------
$FF31 _KEEPPR       Terminate the currently running process

<(SP).l:Resident size (from the beginning of the program to the end of the resident part)
<4(SP).w:Exit code

Does not return

The block containing the process management pointer is left immediately
after the process management pointer for the specified size.

However, if the part to be left extends beyond the end of the memory block,
it will be left up to the end of the memory block.

Any handlers that the running process has opened will not be closed.

The user must close any handlers opened by a process that is to be terminated.

The memory blocks in the resident portion are not released.

The user must free the memory blocks allocated by a resident process that is about to terminate.

If the resident process that is being terminated has changed _EXITVC, _CTRLVC, _ERRJVC and TRAP #10-#14,
the changes will be inherited by the parent process.

The Kana-Kanji conversion line is closed.

The exit code is set to D0.w and the hi word of D0.l is set to 1.

Returns the DOS call level to 0.

PSP($14).l > PC, PSP($44).w > SR and jump to immediately after _EXEC of the parent process.
------------------------------------------------------------------
$FF32 _GETDPB       Gets the DPB table for the specified drive.

<(SP).w:Drive number (0=current, 1=A:)

<2(SP).l:Buffer (94 bytes)

        0000    .b      Internal drive number (0=A:)
        0001    .b      Unit number
        0002    .w      Bytes per sector
        0004    .b      Number of sectors per cluster - 1
        0005    .b      Shift count when converting cluster number to sector number.
                        When bit 7=1, swap the upper and lower bytes of a 2-byte FAT.
        0006    .w      FAT first sector number
        0008    .b      Number of FAT areas
        0009    .b      Number of sectors used for one FAT area
        000A    .w      Number of entries in the root directory
        000C    .w      First sector number of the data section
        000E    .w      Total number of clusters + 1
        0010    .w      First sector number of the root directory
        0012    .l      Device header address
        0016    .b      Media byte
        0017    .b      Internal DPB table usage flag (-1 for no access)
        0018    .l      The following internal DPB tables
        001C    .w      Cluster number of the current directory (0 = root directory)
        001E    .b[64]  Current directory

        (94 bytes)

>D0.l:Error code

The DPB table has a different structure from the internal DPB table,
and _GETDPB creates it in the specified buffer based on the internal DPB table, etc.
------------------------------------------------------------------
$FF33 _BREAKCK      Get or set break and off

<(SP).w:Mode

        $00FF,$FFFF Get break mode
        $0000       Disable break (break=OFF)
        $0001       Enable break (break=ON)
        $0002       Ignore break (break=KILL)
        $0100       Get CTRL+C mode
        $0101       Disable CTRL+C
        $0102       Enable CTRL+C
        $0200       Get CTRL+N mode
        $0201       Disable CTRL+N
        $0202       Enable CTRL+N
        $0300       Get CTRL+P mode
        $0301       Disable CTRL+P
        $0302       Enable CTRL+P
        $0400       Get mode of CTRL+Q
        $0401       Disable CTRL+Q
        $0402       Enable CTRL+Q
        $0500       Get CTRL+S mode
        $0501       Disable CTRL+S
        $0502       Enable CTRL+S

>D0.l:Mode before change

        $00xx,$FFFF 0=Disabled, 1=Enabled, 2=Ignored
        $01xx-$05xx 0=Disabled, 1=Enabled

The specified DOS calls monitor breaks:

        $FF01   _GETCHAR
        $FF02   _PUTCHAR
        $FF03   _COMINP
        $FF04   _COMOUT
        $FF05   _PRNOUT
        $FF08   _GETC
        $FF09   _PRINT
        $FF0A   _GETS
        $FF0B   _KEYSNS
        $FF0C   _KFLUSH
        $FF0D   _FFLUSH
        $FF1E   _FPUTS

------------------------------------------------------------------
$FF34 _DRVXCHG      Swap drive numbers

<(SP).w:Drive number (0 = current drive, 1 = A:)
<2(SP).w:Drive number (0 = current drive, 1 = A:)

        When (SP).w and 2(SP).w are both -1, the drive swap table is initialized.

>D0.l:Error code

Only the apparent drive numbers (drive names) are swapped.
Used by DRIVE.X.
------------------------------------------------------------------
$FF35 _INTVCG       Get an exception vector

<(SP).w:Vector number

        $0002-$00FF Interrupt vector
        $0100-$01FF IOCS call
        $FF00-$FFFF DOS calls, etc.

>D0.l:Vector
------------------------------------------------------------------
$FF36 _DSKFRE       Gets the free space on the specified drive

<(SP).w:Drive number (0=current, 1=A:)
<2(SP).l:Buffer (8 bytes)

        0000    .w  Number of available clusters
        0002    .w  Total number of clusters
        0004    .w  Number of sectors per cluster
        0006    .w  Bytes per sector

        (8 bytes)

>D0.l:Available bytes

If the number of available bytes does not fit into one longword, the returned value d0.l is invalid.
------------------------------------------------------------------
$FF37 _NAMECK       File name check

<(SP).l:File name
<4(SP).l:Buffer (91 bytes)

        0000    .b[2]   'A:'        Drive name
        0002    .b[65]  '\dir\',0   Path
        0043    .b[19]  'file',0    File name
        0056    .b[5]   '.ext',0    Extension

        (91 bytes)

>D0.l:Result

        $FF         No file specified
        $00         No wildcards
        Other       Wildcards available
        Negative    Number Error Code
------------------------------------------------------------------
$FF39 _MKDIR        Create a Directory

<(SP).l:Directory name to create

>D0.l:Error code
------------------------------------------------------------------
$FF3A _RMDIR        Delete a Directory

<(SP).l:The name of the directory to delete

>D0.l:Error code
------------------------------------------------------------------
$FF3B _CHDIR        Set the current directory
<(SP).l:Directory name to set

>D0.l:Error code
*------------------------------------------------------------------
$FF3C _CREATE       Create a new file

<(SP).l:File name
<4(SP).w:Attributes ($0000 is converted to $0020)

        bit 0   R   Not writable
        bit 1   H   Invisible
        bit 2   S   System
        bit 3   V   Volume name
        bit 4   D   Directory
        bit 5   A   File
        bit 6   L   Unused (symbolic link)
        bit 7   E   Unused (executable)
        bit 15      If 1, create a new entry without checking if the same entry already exists.

>D0.l:Handler number
------------------------------------------------------------------
$FF3D _OPEN         Open a Handler

<(SP).l:File name or character device name
<4(SP).w:Open mode

        bit 0-3     Access Mode

            0       Read
            1       Write
            2       Read and write

        bit 4-7     Sharing mode

            0       When reading, allow reading from others (all others prohibited)
            1       No reading or writing by others
            2       No writing by others
            3       Prohibit other users from reading
            4       Allow others to read and write

        bit 8-15    Dictionary file specification

            0       Regular file
            1       Dictionary file

>D0.l:Handler number
------------------------------------------------------------------
$FF3E _CLOSE        Close a Handler

<(SP).w:Handler number

>D0.l:Error code

If you write to the handler, the _CLOSE date and time is set in the directory entry.

However, if the date and time is set by _FILEDATE after the last write, the date and time of _CLOSE will not be set.

Any share management area that is no longer needed due to the handler being closed will be discarded.

Flush the buffer if necessary.

When the standard handler is closed,
a character device with the standard input/output bit of the device type set is opened
and assigned to the standard handler.

When replacing the CON device, you must use this function to _CLOSE the standard input,
standard output, and standard error input/output.
------------------------------------------------------------------
$FF3F _READ         Read the specified size of data from a handler

<(SP).w:Handler number
<2(SP).l:Buffer
<6(SP).l:Size (bytes)

>D0.l:Actual number of bytes entered
------------------------------------------------------------------
$FF40 _WRITE        Write the specified size of data to a handler

<(SP).w:Handler number
<2(SP).l:Buffer
<6(SP).l:Size (bytes)

>D0.l:The actual number of bytes output
------------------------------------------------------------------
$FF41 _DELETE       Delete file

<(SP).l:The name of the file to delete

>D0.l:Error code
------------------------------------------------------------------
$FF42 _SEEK         Change the seek position of a handler

<(SP).w:Handler number
<2(SP).l:Offset (negative values move towards the beginning, positive values move towards the end))
<6(SP).w:Seek mode

        0   From the beginning
        1   From the current position
        2   From the end

>D0.l:Seek position
------------------------------------------------------------------
$FF43 _CHMOD        Read or set attributes of a file or directory

<(SP).l:File or directory name
<4(SP).w:Attribute

        bit 0   R   Not writable
        bit 1   H   Invisible
        bit 2   S   System
        bit 3   V   Volume name
        bit 4   D   Directory
        bit 5   A   File
        bit 6   L   Unused (symbolic link)
        bit 7   E   Unused (executable)
        -1      Read

>D0.l:Attribute
------------------------------------------------------------------
$FF44 _IOCTRL       Direct control of a handler by the device

<(SP).w:Mode

        0   Get device information from handler number

            <2(SP).w:Handler number

            >D0.w:Device information

                bit 15      0=Block devices, special devices
                            1=Character device
                bit 14      0=IOCTRL not possible
                            1=IOCTRL possible
                bit 13      0=Regular device driver
                bit 12      Unused
                            1=Special Device Driver
                bit 12      0=Specialized local device driver
                            1=Specialized Network Device Driver
                bit 11-8    Unused
                bit 7       0=Block devices, special devices

                    bit 6   0=File
                            1=Directory
                    bit 5   Special Device Driver
                    bit 4-0 Internal drive number (0=A:)

                            1=Character device

                    bit 6   EOF ON/OFF
                    bit 5   0=COOKED mode
                            1=RAW mode
                    bit 4   Unused
                    bit 3   1=CLOCK
                    bit 2   1=NUL
                    bit 1   1=Standard output
                    bit 0   1=Standard input

        1   Set device information to the handler number (only RAW/COOKED can be set)

            <2(SP).w:Handler number
            <4(SP).w:Device information

        2   Read from the handler number

            <2(SP).w:Handler number
            <4(SP).l:Pointer
            <8(SP).l:Size

        3   Write to handler number

            <2(SP).w:Handler number
            <4(SP).l:Pointer
            <8(SP).l:Size

        4   Read from drive number

            <2(SP).w:Drive number
            <4(SP).l:Pointer
            <8(SP).l:Size

        5   Write to drive number

            <2(SP).w:Drive number
            <4(SP).l:Pointer
            <8(SP).l:Size

        6   Get input status from handler number

            <2(SP).w:Handler number

        7   Get output status from handler number

            <2(SP).w:Handler number

        9   Determine if a drive number is local or remote

            <2(SP).w:Drive number (0=current, 1=A:)

        10  Check if the handler number is local or remote

            <2(SP).w:Handler number
            >D0.w:Device information

        11  Set the number of retries and the retry wait time (in 1/100 seconds)

            <2(SP).w:Retry count
            <4(SP).w:Retry wait time

        12  Special control by handler number

            <2(SP).w:Handler number
            <4(SP).w:Command
            <6(SP).l:Pointer

        13  Special control by drive number

            <2(SP).w:Drive number
            <4(SP).w:Command
            <6(SP).l:Pointer
------------------------------------------------------------------
$FF45 _DUP          Duplicate a Handler

<(SP).w:Handler number

>D0.l:Handler number

A single FCB can be accessed using multiple handler numbers.

Closing one of the handlers does not close the FCB.
------------------------------------------------------------------
$FF46 _DUP2         Duplicate a Handler

<(SP).w:Source handler number
<2(SP).w:Destination handler number

>D0.l:FCB number

If the destination handler is already open, it will be closed before copying.

Redirection of a standard handler is achieved by saving the current standard handler with _DUP, 
and then copying the newly opened handler to the standard handler with _DUP2.
------------------------------------------------------------------
$FF47 _CURDIR       Get the current directory

<(SP).w:Drive number (0=current, 1=A:)
<2(SP).l:Buffer (excluding drive name and surrounding '\')

>D0.l:Error code
------------------------------------------------------------------
$FF48 _MALLOC       Allocate a memory block (from the bottom)

<(SP).l:Size to reserve

>D0.l:The starting address of the allocated memory block

        $81??????   Maximum size that can be secured
        $8200000?   Not secured at all

*Memory blocks are searched from the bottom up.
------------------------------------------------------------------
$FF49 _MFREE        Free a memory block

<(SP).l:The starting address of the memory block to be released

        If 0, all memory blocks allocated by the running process are released.

>D0.l:Error code

        $FFFFFFF7   An invalid memory management table was specified.
------------------------------------------------------------------
$FF4A _SETBLOCK     Change the size of a memory block

<(SP).l:The starting address of the memory block
<4(SP).l:New size (from just after the memory management table to the end of the memory block)

>D0.l:Error code
------------------------------------------------------------------
$FF4B _EXEC         Run a child process

<(SP).b:Module number
<1(SP).b:Mode

        0   Load and run a program

            <2(SP).l:Executable File Name

                The most significant byte is the executable file type (0=extension, 1=r, 2=z, 3=x).

            <6(SP).l:Command line
            <10(SP).l:Address of the environment (if 0, the environment of the running process)

            >D0.l:Exit code (hi word = 1 when resident)

        1   Load a Program

            <2(SP).l:Executable File Name

                The most significant byte is the executable file type (0=extension, 1=r, 2=z, 3=x).

            <6(SP).l:Command line
            <10(SP).l:Address of the environment (if 0, the environment of the running process)

            >D0.l:Execution start address
            >A0.l:Memory management table
            >A1.l:End of program +1
            >A2.l:Command line
            >A3.l:Environment
            >A4.l:Execution start address

            The loaded program is executed in _EXEC mode 4.

        2   Search the path of the executable file name

            <2(SP).l:Executable file name and command line

                The most significant byte is the executable file type (0=extension, 1=r, 2=z, 3=x).

            <6(SP).l:Command line buffer
            <10(SP).l:Address of the environment (if 0, the environment of the running process)

            >D0.l:Error code

            It does not affect the process's environment.

        3   Load an executable file at a specified address

            <2(SP).l:Executable File Name

                The most significant byte is the executable file type (0=extension, 1=r, 2=z, 3=x).

            <6(SP).l:Load address
            <10(SP).l:Limit address

            >D0.l:Error code

            Used to load device drivers.

        4   Run a loaded program

            <2(SP).l:Execution start address

            >D0.l:Exit code (hi word = 1 when resident)

            _EXEC mode 1 executes the loaded program.

        5   Module number search (returns the last module number found)
        
            <2(SP).l:Executable File Name
            <6(SP).l:Module name

            >D0.l:Module number *$100

            Calculate the module number from the executable file name and module name.
------------------------------------------------------------------
$FF4C _EXIT2        Process termination (with exit code specified)

<(SP).w:Exit code

Does not return

Closes all handlers that the current process has open.

Frees all memory blocks used by the current process.

Transfers process management to the parent process.

Restore the stack pointer as PSP($40).l>SSP, PSP($3C).l>USP.

Restores _EXITVC, _CTRLVC, _ERRJVC and TRAP #10-#14 according to the process management table of the parent process.

Closes the Kana-Kanji conversion line.

The exit code is set to D0.w and the hi word of D0.l is set to 0.

Returns the DOS call level to 0.

PSP($14).l > PC, PSP($44).w > SR and jump to immediately after _EXEC of the parent process.
------------------------------------------------------------------
$FF4D _WAIT         Get the exit code of a child process

No parameters

>D0.l:Child process exit code
------------------------------------------------------------------
$FF4E _FILES        Directory entry search (first)

<(SP).l:_FILES buffer (53 bytes or 141 bytes)

        bit 31  1=Append the 88-byte path to the end of the _FILES buffer.

        0000    .b      Attributes to search for
        0001    .b      Internal drive number to search (0=A:)
        0002    .l      Sector number where the entry is located
        0006    .w      Number of consecutive sectors - 1
        0008    .w      Offset from the beginning of the sector

                        $FFFF=There is no matching file anymore

        000A    .b[8]   The file name to search for
        0012    .b[3]   The extension to search for
        0015    .b      Attribute

                        bit 0   R   Not writable
                        bit 1   H   Invisible
                        bit 2   S   System
                        bit 3   V   Volume name
                        bit 4   D   Directory
                        bit 5   A   File
                        bit 6   L   Unused (symbolic link)
                        bit 7   E   Unused (executable)

        0016    .w      Time
        0018    .w      Date
        001A    .l      File size
        001E    .b[23]  File name

        (53 bytes)

        (The following is valid when bit 31 of the _FILES buffer address is set to 1)

        0035    .b[2]   'A:'        Internal drive name (A:-)
        0037    .b[65]  '\dir\',0   Path (separated by '\')
        0078    .b[8]   'file    '  File name 1 (the rest are $20 or '?')
        0080    .b[3]   '   '       Extension (the rest is $20 or '?')
        0083    .b[10]  0           File name 2 (the rest are 0)

        (141 bytes)

<4(SP).l:The file name to search for
<8(SP).w:Attributes to search for

        Lo byte: Attribute to search for
        Hi byte: 1 = Fill the rest of the searched file name with '?' instead of $20

>D0.l:Error code

Search for the second and subsequent matching entries with _NFILES.
------------------------------------------------------------------
$FF4F _NFILES       Searching for directory entries (next)

<(SP).l:_FILES buffer (53 bytes or 141 bytes)

>D0.l:Error code

The first matching entry is searched for with _FILES.
------------------------------------------------------------------
$FF80 _SETPDB       Move the process management table

<(SP).l:New process management table start address

>D0.l:The start address of the original process management table

Migrate process management to an existing process management table.

Change _EXITVC, _CTRLVC, _ERRJVC and TRAP #10-#14 according to the process management table of the migration destination.

This is used when you want to temporarily transfer process management to a resident process.
------------------------------------------------------------------
$FF81 _GETPDB       Get the process management table

>D0.l:Start address of process management table (240 bytes) (memory management table + 16)

        (The memory management table starts at 0000.)

        0010    .l      Address of the environment area
        0014    .l      _EXITVC vector (immediately after the parent's _EXEC)
        0018    .l      _CTRLVC vector
        001C    .l      _ERRJVC vector
        0020    .l      Command Line Address
        0024    .b[12]  Handler usage
        0030    .l      beginning of bss
        0034    .l      Top of the heap
        0038    .l      Top of the stack area
        003C    .l      Parent's USP
        0040    .l      Parent's SSP
        0044    .w      Parent's SR
        0046    .w      SR at abort
        0048    .l      SSP at abort
        004C    .l      TRAP #10 vector
        0050    .l      TRAP #11 vector
        0054    .l      TRAP #12 vector
        0058    .l      TRAP #13 vector
        005C    .l      TRAP #14 vector
        0060    .l      OS flag (-1 = Human boot, 0 = Other)
        0064    .b      Module number
        0065    .b[3]   Unused
        0068    .l      Child process memory management table
        006C    .l[5]   Reserved
        0080    .b[68]  Path to the executable file
        00C4    .b[24]  Executable file name
        00DC    .l[9]   Reserved

        (240 bytes)

Obtains the start address of the process management table of the currently running process.
------------------------------------------------------------------
$FF82 _SETENV       Set an environment variable

<(SP).l:Environment variable name
<4(SP).l:Environment space (if 0, use the environment space of the running process)
<8(SP).l:Buffer

>D0.l:Error code

If the buffer starts at 0, the specified environment variable is deleted.
------------------------------------------------------------------
$FF83 _GETENV       Get an environment variable

<(SP).l:Environment variable name
<4(SP).l:Environment space (if 0, use the environment space of the running process)
<8(SP).l:Buffer

>D0.l:Error code
------------------------------------------------------------------
$FF84 _VERIFYG      Get the verify mode
No parameters

>D0.l:Verify mode (0=OFF, 1=ON)
------------------------------------------------------------------
$FF85 _COMMON       Control the common area

<(SP).w:Mode

        0   Search for the common area

            <2(SP).l:Common area name

            >D0.l:Number of bytes in the common area

        1   Read from the common area

            <2(SP).l:Common area name
            <6(SP).l:Position
            <10(SP).l:Buffer
            <14(SP).l:Number of transferred bytes

            >D0.l:The actual number of bytes transferred

        2   Write to the common area

            <2(SP).l:Common area name
            <6(SP).l:Position
            <10(SP).l:Buffer
            <14(SP).l:Number of transferred bytes

            >D0.l:The actual number of bytes transferred

        3   Lock the common area

            <2(SP).l:Common area name
            <6(SP).l:Position
            <10(SP).l:First address of the process management table
            <14(SP).l:Number of bytes to lock

            >D0.l:Error code

        4   Unlock the common area

            <2(SP).l:Common area name
            <6(SP).l:Position
            <10(SP).l:First address of the process management table
            <14(SP).l:The number of bytes to unlock

            >D0.l:Error code

        5   Delet the common area

            <2(SP).l:Common area name

            >D0.l:Error code
------------------------------------------------------------------
$FF86 _RENAME       Rename files or directories and move files

<(SP).l:File name before change
<4(SP).l:Changed file name

>D0.l:Error code

If the path before and after the change is different, the file will be moved.

You cannot move between drives that are different entities.

Directories cannot be moved.
------------------------------------------------------------------
$FF87 _FILEDATE     Get or set the date and time of a file

<(SP).w:Handler number
<2(SP).l:Date and time (read when both are 0)

        Hi word: Date(((Year-1980)<<9)+(Month<<5)+Day)

            yyyyyyym_mmmddddd

                y   Year-1980(0-99)
                m   Month (1-12)
                d   Day (1-31)

        Lo word: Time ((hours<<11)+(minutes<<5)+(seconds/2))

            hhhhhmmm_mmmsssss

                h   Hour (0-23)
                m   Minutes (0-59)
                s   Seconds/2(0-29)

>D0.l:(When reading) Date and time

        Hi word: Date
        Lo word: Time

The handler's modification date is set in the directory entry.

If you do not set the date and time using _FILEDATE for a file you have written to,
or if you write to a file after setting _FILEDATE, 
the date and time when you _CLOSE it will be set in the directory entry.
------------------------------------------------------------------
$FF88 _MALLOC2      Allocate a memory block (mode specified)

<(SP).w:Mode

        bit 0-7 Mode

            0   From the bottom
            1   From the minimum required blocks
            2   From the top

        bit 15  Process-specific flags

            0   Running Processes
            1   Use 6(SP) as the process memory management table

<2(SP).l:Size to reserve
<6(SP).l:(When the process specification flag is 1)

        The value to use instead of the memory management table of the running process

>D0.l:The starting address of the allocated memory block

        $81??????   Maximum size that can be secured
        $8200000?   Not secured at all

Reserves a block of memory from the current thread's memory manager according to the selected mode.

By specifying a process, you can create a memory block that will not be released even if you execute _EXIT.
------------------------------------------------------------------
$FF8A _MAKETMP      Create a temporary file

<(SP).l:File name
<4(SP).w:Attributes ($0000 is converted to $0020)

        bit 0   R   Not writable
        bit 1   H   Invisible
        bit 2   S   System
        bit 3   V   Volume name
        bit 4   D   Directory
        bit 5   A   File
        bit 6   L   Unused (symbolic link)
        bit 7   E   Unused (executable)
        bit 15  If 1, create a new entry without checking if the same entry already exists.

>D0.l:Handler number

If the file name contains a sequence of '?', it will be converted to a sequence of '0'.

If the file already exists, the numeric part of the filename is incremented to create a non-existent filename.
------------------------------------------------------------------
$FF8B _NEWFILE      Create a new file (non-destructive)

<(SP).l:File name
<4(SP).w:Attributes ($0000 is converted to $0020)

        bit 0   R   Not writable
        bit 1   H   Invisible
        bit 2   S   System
        bit 3   V   Volume name
        bit 4   D   Directory
        bit 5   A   File
        bit 6   L   Unused (symbolic link)
        bit 7   E   Unused (executable)
        bit 15  If 1, create a new entry without checking if the same entry already exists.

>D0.l:Handler number

If a file with the same name already exists, an error occurs.
------------------------------------------------------------------
$FF8C _LOCK         Control the locking of a handler

<(SP).w:Mode

        0   Lock
        1   Unlock

<2(SP).w:Handler number
<4(SP).l:Seek position to lock/unlock
<8(SP).l:Number of bytes to lock/unlock
------------------------------------------------------------------
$FF8F _ASSIGN       Get and set virtual drives and directories

<(SP).w:Mode

        0   Acquisition

            <2(SP).l:Drive name
            <6(SP).l:Buffer

            >D0.l:Mode

                $40 No assignment exists
                $50 Virtual drive
                $60 Virtual directory

        1   Setting

            <2(SP).l:Drive name
            <6(SP).l:Directory name
            <10(SP).w:Mode

                $50 Virtual drive
                $60 Virtual directory

            >D0.l:Error code

        4   Cancellation

            <2(SP).l:Drive name

            >D0.l:Error code
------------------------------------------------------------------
$FFAA _FFLUSMD      Get or set the mode of _FFLUSH

<(SP).w:_FFLUSH mode (0=OFF, 1=ON, -1=Get only)

>D0.l:Original _FFLUSH mode (0=OFF, 1=ON)

You can disable _FFLUSH.
------------------------------------------------------------------
$FFAB _OS_PATCH     Patch Human

<(SP).b:If it is other than 0, the first management routine is called.
<1(SP).b:Type of Management Routines

        1   Buffer management routines
        2   FAT management routines
        3   Directory management routines
        4   Filename management routines

<2(SP).l:Jump table start address

        (Jump table for buffer management routines)

        0000
        0006    Initialize the buffers
        000C    Buffer Flush
        0012    Prepare the specified sector at the beginning of the buffer (actually read, $40)
        0018    Prepare the specified sector at the beginning of the buffer (actually read, $20)
        001E    Prepare the specified sector at the beginning of the buffer (does not actually read it, $20)
        0024    Prepare the specified sector at the beginning of the buffer (actually read, $10)
        002A    Prepare the specified sector at the beginning of the buffer (does not actually read it, $10)
        0030    Check if the sector number and buffer match
        0036    Flush one buffer
        003C    (Drive control #6 when buffer is being flushed)
        0042    Flush the buffers associated with a specific internal DPB table
        0048    Invalidate the buffer associated with a specific internal DPB table
        004E    Direct sector read (_DISKRED)
        0054    Direct sector write (_DISKWRT)
        005A
        0060
        0066
        006C
        0072

        (Jump table for FAT management routines)

        0000
        0006
        000C    (Buffer Flush)
        0012
        0018    Count the number of contiguous clusters that can be allocated from the specified cluster.
        001E    Get the FAT of the specified cluster number
        0024    Find unused clusters
        002A    Get the number of unused clusters
        0030    Make the specified cluster unused until the end of the chain
        0036    Make the specified cluster unused
        003C    Modify the FAT of the specified cluster
        0042    (Invalidating buffers related to a specific internal DPB table)
        0048    (Flush the buffers associated with a particular internal DPB table)
        004E
        0054
        005A
        0060
        0066
        006C
        0072

        (Jump table for directory management routines)

        0000
        0006
        000C    (Buffer Flush)
        0012    Entry search (other than _FILES, _NFILES)
        0018    (Created a new file entry)
        001E    (Entry changed/deleted)
        0024    (Get the directory sector number from the file name path)
        002A    (The sector number was obtained from the directory name)
        0030    (Directory entry changed or deleted)
        0036    (Invalidate buffers related to a specific internal DPB table)
        003C
        0042
        0048
        004E
        0054
        005A
        0060
        0066

        (Jump table for file name management routines)

        0000
        0006    Initialization (set a table of characters that cannot be used in file names)
        000C    Clean up (do nothing)
        0012    Check if the file name is a device and return the device header
        0018    Compare filename 1 with the extension (wildcards are allowed with ?)
        001E    Compare file names in _NAMESTS format
        0024    File name comparison (with length specification)
        002A    Copy filenames while removing "." and ".."
        0030    Generate a file name in _NAMESTS format from the file name
        0036    Copy filename1 and extension from _NAMESTS format filename to the OS area of _FILES
        003C    Get the address of file name 1 from the address of the _FILES buffer
        0042    (Called when not found error in _FILES, _NFILES)
        0048    Create a file name from the sequence of filename1, extension, and filename2
        004E    The command line file name and parameter separator (/-"')
        0054    Copy the file name while converting the directory name separator to $09
                (Called when a character that cannot be used in a file name is not defined)
        005A
        0060
        0066
        006C
        0072

>D0.l:The starting address of the original jump table

It is used by FASTIO.X, FASTSEEK.X, FASTOPEN.X, TwentyOne.x, etc.
------------------------------------------------------------------
$FFAC _GETFCB       Get FCB Table

<(SP).w:Handler number

>D0.l:Address of the FCB table (96 bytes)

        0000    .b      Number of references to the FCB table:
                        How many times the handler FCB translation table is referenced (if 0, unused)
        0001    .b[6]

            0001    .b  FCB Flag

                bit 7   0 = Block devices, special devices

                            bit 6       1 = Update the date and time when _CLOSE is performed
                            bit 5       Special Device Drivers
                            bit 4-0     Internal drive number (0=A:)

                        0002    .l  Internal DPB Table

                        1 = Character device

                            bit 6       EOF ON/OFF
                            bit 5       0 = Cooked mode, 1 = Raw mode
                            bit 4       Unused
                            bit 3       1=CLOCK
                            bit 2       1=NUL
                            bit 1       1=Standard output
                            bit 0       1=Standard input

                        0002    .l  Device header

        0006    .l  current_SEEK position
        000A    .l  Share management table address
        000E    .b  Open mode

            bit 0-3 (Access Mode)

            0   Read

                1   Write
                2   Read and write
                3   _CHMOD,_DELETE,_RENAME
                4

        (Special device drivers may freely use the following areas)

        000F    .b      The entry number within the sector
        0010    .b      Sector position within the cluster being accessed
        0011    .b      Sector offset from the beginning of the FAT
        0012    .w      Sector offset from the beginning of the FAT (to the currently accessed FAT)
        0014    .l      Current data sector location
        0018    .l      Current data buffer address
        001C    .l      Directory sector location
        0020    .l      Next FCB Table
        0024    .b[8]   Device Name or File Name 1
        002C    .b[3]   Extension
        002F    .b      File attributes
        0030    .b[10]  File name 2
        003A    .w      Time
        003C    .w      Date
        003E    .w      The first cluster number of this file
        0040    .l      File size
        0044    .w      Cluster number 1 on the disk
        0046    .w      Cluster number 1 in the file
        0048    .w      Cluster number 2 on the disk
        004A    .w      Cluster number 2 in the file
        004C    .w      Cluster number 3 on the disk
        004E    .w      Cluster number 3 in the file
        0050    .w      Cluster number 4 on the disk
        0052    .w      Cluster number 4 in the file
        0054    .w      Cluster number 5 on the disk
        0056    .w      Cluster number 5 in the file
        0058    .w      Cluster number 6 on the disk
        005A    .w      Cluster number 6 in the file
        005C    .w      Cluster number 7 on the disk
        005E    .w      Cluster number 7 in the file

        (96 bytes)
------------------------------------------------------------------
$FFAD _S_MALLOC     Allocate a block of memory from the main thread's memory management

<(SP).w:Mode

        bit 0-7 Mode

            0   From the bottom
            1   From the minimum required blocks
            2   From the top

        bit 15  Process-specific flags

            0   Running Processes
            1   Use 6(SP) as the process memory management table

<2(SP).l:Size to reserve
<6(SP).l:(When the process specification flag is 1)

        The value to use instead of the memory management table of the running process

>D0.l:The starting address of the allocated memory block

        $81??????   Maximum size that can be secured
        $8200000?   Not secured at all
------------------------------------------------------------------
$FFAE _S_MFREE      Release a memory block from the main thread's memory management

<(SP).l:The starting address of the memory block to be released

>D0.l:Error code

        $FFFFFFF7   An invalid memory management table was specified.

When the memory management of the running thread is released, the running thread is deleted by _KILL_PR.

Processes that have terminated in the sub memory management are supposed 
to be incorporated into the main memory management, but due to a bug in Human, 
the incorporation is incomplete, so the memory blocks of processes that have terminated are destroyed.
------------------------------------------------------------------
$FFAF _S_PROCESS    Set the sub-memory management for the specified thread

<(SP).w:Thread number (other than 0)
<2(SP).l:The starting address of the memory block
<6(SP).l:Sub-memory management size
<10(SP).l:First block size

>D0.l:Start of user area of first block

        $FFFFxxxx   Maximum thread number
        $FFFFFFF2   The memory block specification is incorrect.

Allocates part of the main thread's memory block to the sub-thread's memory management.
Sub memory management is released by _SMFREE.
------------------------------------------------------------------
$FFF0 _EXITVC       Process end address

This is not a DOS call.

The _EXITVC vector holds the address to jump to when the process terminates with _EXIT, _KEEPPR, or _EXIT2.

By default, _EXITVC is set to the address immediately after _EXEC of the parent process.

In principle, the _EXITVC vector is never changed.
------------------------------------------------------------------
$FFF1 _CTRLVC       ^C abort address

This is not a DOS call.

The _CTRLVC vector holds the address to jump to on a ^C abort.

Aborts caused by ^C are handled when ^C is pressed within each DOS call, 
and the return address from the DOS call is rewritten to the _CTRLVC vector, causing a jump to the _CTRLVC vector.

The _CTRLVC vector has a routine set to execute _EXIT by default.

Aborting with ^C is restricted by the mode of the break.

When break=ON, it is valid for all DOS calls, when break=OFF it is valid for DOS calls related to standard I/O, 
when break=KILL it is invalid for all DOS calls.

Always use _INTVCS when modifying this vector.

By using _INTVCS to change the _CTRLVC vector, you can prevent an abort with ^C from returning to the parent process.

Note that if you change the vector of _CTRLVC using _INTVCS, the vector of _ERRJVC will also be changed at the same time.

If you change the abort handling, the sr and ssp values saved by _INTVCS are loaded on abort, but USP is not restored.

Therefore, you must reset the USP at the beginning of the abort routine.
------------------------------------------------------------------
$FFF2 _ERRJVC       Error abort address

This is not a DOS call.

The _ERRJVC vector holds the address to jump to in case of an error abort.

Aborts due to errors are handled by _ABORTJOB, which is called when Abort <A> is selected in the white window of trap#14,
and jumps to the _ERRJVC vector at the end of _ABORTJOB.

The _ERRJVC vector has a routine set to execute _EXIT by default.

Always use _INTVCS when modifying this vector.

By using _INTVCS to change the _ERRJVC vector, you can prevent an error abort from returning to the parent process.

If you change the abort handling, the sr and SSP values saved by _INTVCS are loaded on abort, but USP is not restored.

Therefore, the USP must be reset at the beginning of the abort routine.
------------------------------------------------------------------
$FFF3 _DISKRED      Read directly from a device

<(SP).l:The starting address of the buffer

        When bit 31=0

            <4(SP).w:Drive number (0 = current drive, 1 = A:)
            <6(SP).w:First sector number
            <8(SP).w:Number of sectors

                Special devices and block devices whose sector size is not $0400 will result in an error.

        When bit 31=1

            <4(SP).w:Drive number (0 = current drive, 1 = A:)
            <6(SP).l:First sector number
            <10(SP).l:Number of sectors

Virtual drives and virtual directories will result in an error.
------------------------------------------------------------------
$FFF4 _DISKWRT      Write directly to a device

<(SP).l:The starting address of the buffer

        When bit 31=0

            <4(SP).w:Drive number (0 = current drive, 1 = A:)
            <6(SP).w:First sector number
            <8(SP).w:Number of sectors
                
                Special devices and block devices whose sector size is not $0400 will result in an error.

        When bit 31=1

            <4(SP).w:Drive number (0 = current drive, 1 = A:)
            <6(SP).l:First sector number
            <10(SP).l:Number of sectors

Virtual drives and virtual directories will result in an error.
------------------------------------------------------------------
$FFF5 _INDOSFLG     Acquire Human work area

No parameters

>D0.l:First address of Human work area ($1C08.w)

        0000    .w  DOS call level (starting from _INDOSFLG)
        0002    .b  DOS call number entered at level 0
        0003    .b  Newfat mode (0 or 2)
        0004    .w  Retry count
        0006    .w  Retry wait time
        0008    .w  Verify mode (0=OFF, 1=ON)
        000A    .b  Break mode (0=OFF, 1=ON, 2=KILL)
        000B    .b  CTRL+P mode (0=OFF, -1=ON)
        000C    .b  Switch threads when a DOS call ends (0=NO, 1=YES)
        000D    .b  Current drive number (0=A:)

You may not change the contents of the work area without permission.

This call cannot be modified by _INTVCS.

Modifying the vector in _INDOSFLG has no effect.
------------------------------------------------------------------
$FFF6 _SUPER_JSR    Call a subroutine in supervisor mode

<(SP).l:Address

No return value

This call cannot be modified by _INTVCS.

Modifying the vector in _SUPER_JSR has no effect.
------------------------------------------------------------------
$FFF7 _BUS_ERR      Bus error check

<(SP).l:Address to read
<4(SP).l:Address to write to
<6(SP).w:Size

        1   Byte
        2   Word
        4   Long word

>D0.l:Bus error occurrence status

        0   Read and write success
        1   Read successful, write failed
        2   Read failure
        -1  The parameters are incorrect
            
            An attempt was made to access an odd address or a different size in word or long word format.

At the specified address, try reading and writing to see if a bus error occurs.

This call cannot be modified by _INTVCS.

Modifying the _BUS_ERR vector has no effect.
------------------------------------------------------------------
$FFF8 _OPEN_PR      Create a new thread

<(SP).l:Thread name (16 bytes)
<4(SP).w:Priority level (2 (highest priority) - 256)
<6(SP).l:USP
<10(SP).l:SSP
<14(SP).w:SR
<16(SP).l:PC
<20(SP).l:Address of the inter-thread communication buffer (12 bytes)

        0000    .l  Buffer size
        0004    .l  The address of the buffer
        0008    .w  Command (-1 = can receive)
        000A    .w  Thread number of the thread that requested communication

        (12 bytes)

<24(SP).l:Wait time (0 for permanent sleep)

>D0.l:Thread number

The new thread will wake up on its own after the wait time has elapsed.

However, if you set the wait time to 0, it will go into a permanent sleep state
and will not wake up until woken up by _SEND_PR.

This call cannot be changed by _INTVCS, 
but the routine set in the vector of _OPEN_PR is called by Human when a thread is added by _OPEN_PR.

The parameter to the routine is D0.w = the created thread number.

The default is a no-op routine.
------------------------------------------------------------------
$FFF9 _KILL_PR      Killing a running thread

No parameters

>D0.l:Error code

Closes all handlers opened by the running process and its child processes.

Frees all memory blocks used by the running process.

Wake up the next thread.

This call cannot be changed by _INTVCS,
but the routine set in the _KILL_PR vector will be called by Human when the thread is deleted by _KILL_PR or _S_MFREE.

The parameter of the routine is D0.w = spawned thread number - 1.

By default, the routine is set to do nothing.
------------------------------------------------------------------
$FFFA _GET_PR       Get the thread management table for the specified thread number

<(SP).w:Thread number

        -1      Get the thread number and its thread management table from the thread name.
        -2      Get the running thread number and its thread management table.
        Other   Get the thread management table for the specified thread number.

<2(SP).l:Buffer (11'6 bytes)

        0000    .l      Next thread management table address
        0004    .b      Wait flag (-2 = forced sleep, -1 = sleep, 0 = running)
        0005    .b      Counter
        0006    .b      Maximum count (Priority level)
        0007    .b      DOS call number being executed (entered at level 0)
        0008    .l      Memory management tables of running processes
        000C    .l      USP
        0010    .l      D0
        0014    .l      D1
        0018    .l      D2
        001C    .l      D3
        0020    .l      D4
        0024    .l      D5
        0028    .l      D6
        002C    .l      D7
        0030    .l      A0
        0034    .l      A1
        0038    .l      A2
        003C    .l      A3
        0040    .l      A4
        0044    .l      A5
        0048    .l      A6
        004C    .w      SR
        004E    .l      PC
        0052    .l      SSP
        0056    .w      DOS call level
        0058    .l      SP when DOS call is entered at level 0
        005C    .l      Inter-thread communication buffer address
        0060    .b[16]  Thread name
        0070    .l      Wait time

        (116 bytes)

        (The following is not copied by _GET_PR)

        0074    .l      Start address of memory space that can be _MALLOC'd
        0078    .l      End address of memory space that can be _MALLOCed + 1

        (124 bytes)

This call cannot be modified by _INTVCS.

Modifying the vector in _GET_PR has no effect.
------------------------------------------------------------------
$FFFB _SUSPEND_PR   Force the specified thread to sleep

<(SP).w:Thread number

>D0.l:Error code

        0           Normal termination
        $FFFFxxxx   Maximum thread number
        $FFFFFFFF   Attempting to force a running thread to sleep

This call cannot be modified by _INTVCS.

Changing the vector of _SUSPEND_PR has no effect.
------------------------------------------------------------------
$FFFC _SLEEP_PR     Put the running thread to sleep

<(SP).l:Latency (ms)

>D0.l:Situation

        -1      The waiting time had passed so giving up.
        -2      After the waiting time has elapsed, it is woken up by _SEND_PR
        Other   Woke up by _SEND_PR with remaining time (ms)

This call cannot be modified by _INTVCS.

Changing the vector of _SLEEP_PR has no effect.
------------------------------------------------------------------
$FFFD _SEND_PR      Wake up a thread

<(SP).w:My thread number
<2(SP).w:Other party's thread number
<4(SP).w:Command

        (commands reserved by the system)

        $FFF9   Thread deletion request
        $FFFB   Just wake it up (inter-thread communication buffers do not change)
        $FFFC   Sleep request
        $FFFF   Check if the process is complete

<6(SP).l:Buffer
<10(SP).l:Buffer size

>D0.l:Error code

        0           Normal termination
        $FFFFFFE4   Write error
        $FFFF00xx   Maximum thread number
        $80xxxxxx   Maximum buffer size

Wakes up the thread with the specified thread number by writing to the inter-thread communication buffer.

This call cannot be modified by _INTVCS.

Modifying the vector of _SEND_PR has no effect.
------------------------------------------------------------------
$FFFE _TIME_PR      Get the current timer counter value

No parameters

>D0.l:Timer counter value

The timer counter is a counter that counts up in milliseconds.

This call cannot be modified by _INTVCS.

Changing the vector of _TIME_PR has no effect.
------------------------------------------------------------------
$FFFF _CHANGE_PR    Switch to the next thread

No parameters

No return value

This call cannot be changed by _INTVCS, 
but the routine set in the _CHANGE_PR vector will be called by Human when the thread is switched.

The parameter of this routine is D0.w = the next thread number to run.

The default is a no-op routine.
------------------------------------------------------------------


DOS call list (in code order)
------------------------------------------------------------------
Number Call name    Function overview
------------------------------------------------------------------
$FF00 _EXIT         Process termination (no exit code specified)
$FF01 _GETCHAR      Read one byte from standard input (echoed back to standard output)
$FF02 _PUTCHAR      Output one byte to standard output
$FF03 _COMINP       Read one byte from standard serial I/O
$FF04 _COMOUT       Output one byte to standard serial I/O
$FF05 _PRNOUT       Output one byte to the standard printer output
$FF06 _INPOUT       Standard I/O handler input/output
$FF07 _INKEY        Read one byte from standard input (does not process ^C, ^P, ^N)
$FF08 _GETC         Read one byte from standard input (processes ^C, ^P, ^N)
$FF09 _PRINT        Output a string to standard output
$FF0A _GETS         Read a string from standard input (processes ^C, ^P, ^N)
$FF0B _KEYSNS       Read one byte ahead from standard input
$FF0C _KFLUSH       Flush the standard input buffer and then read from standard input.
$FF0D _FFLUSH       Buffer Flush
$FF0E _CHGDRV       Change the current drive
$FF0F _DRVCTRL      Drive control
------------------------------------------------------------------
$FF10 _CONSNS       Check whether output to standard output is possible
$FF11 _PRNSNS       Check whether output to a standard printer is possible
$FF12 _CINSNS       Check whether input from standard serial I/O is possible
$FF13 _COUTSNS      Check whether output to standard serial input/output is possible
$FF17 _FATCHK       Check the FAT connections of files and directories
$FF18 _HENDSP       Kana-Kanji conversion window control
$FF19 _CURDRV       Get the current drive number
$FF1A _GETSS        Read a string from standard input (does not process ^C, ^P, ^N)
$FF1B _FGETC        Read one byte from the specified handler
$FF1C _FGETS        Read a string from the specified handler
$FF1D _FPUTC        Output one byte to the specified handler
$FF1E _FPUTS        Output a string to the specified handler
$FF1F _ALLCLOSE     Close all handlers opened by the running process and its child processes
------------------------------------------------------------------
$FF20 _SUPER        Switch between processor modes
$FF21 _FNCKEY       Read and set redefinable keys
$FF22 _KNJCTRL      Kana-Kanji conversion control
$FF23 _CONCTRL      Console output control
$FF24 _KEYCTRL      Console input control
$FF25 _INTVCS       Set an exception handling vector
$FF26 _PSPSET       Create a process management table
$FF27 _GETTIM2      Get the time (long word)
$FF28 _SETTIM2      Set the time (long word)
$FF29 _NAMESTS      Filename decomposition
$FF2A _GETDATE      Get the date
$FF2B _SETDATE      Set the date
$FF2C _GETTIME      Get the time (word)
$FF2D _SETTIME      Set the time (word)
$FF2E _VERIFY       Set verify mode
$FF2F _DUP0         Convert a standard handler
------------------------------------------------------------------
$FF30 _VERNUM       Get Human version
$FF31 _KEEPPR       Terminate the currently running process
$FF32 _GETDPB       Gets the DPB table for the specified drive.
$FF33 _BREAKCK      Get or set break and off
$FF34 _DRVXCHG      Swap drive numbers
$FF35 _INTVCG       Get an exception vector
$FF36 _DSKFRE       Gets the free space on the specified drive
$FF37 _NAMECK       File name check
$FF39 _MKDIR        Create a Directory
$FF3A _RMDIR        Delete a Directory
$FF3B _CHDIR        Set the current directory
$FF3C _CREATE       Create a new file
$FF3D _OPEN         Open a Handler
$FF3E _CLOSE        Close a Handler
$FF3F _READ         Read the specified size of data from a handler
------------------------------------------------------------------
$FF40 _WRITE        Write the specified size of data to a handler
$FF41 _DELETE       Delete file
$FF42 _SEEK         Change the seek position of a handler
$FF43 _CHMOD        Read or set attributes of a file or directory
$FF44 _IOCTRL       Direct control of a handler by the device
$FF45 _DUP          Duplicate a Handler
$FF46 _DUP2         Duplicate a Handler
$FF47 _CURDIR       Get the current directory
$FF48 _MALLOC       Allocate a memory block (from the bottom)
$FF49 _MFREE        Free a memory block
$FF4A _SETBLOCK     Change the size of a memory block
$FF4B _EXEC         Run a child process
$FF4C _EXIT2        Process termination (with exit code specified)
$FF4D _WAIT         Get the exit code of a child process
$FF4E _FILES        Directory entry search (first)
$FF4F _NFILES       Searching for directory entries (next)
------------------------------------------------------------------
$FF80 _SETPDB       Move the process management table
$FF81 _GETPDB       Get the process management table
$FF82 _SETENV       Set an environment variable
$FF83 _GETENV       Get an environment variable
$FF84 _VERIFYG      Get the verify mode
$FF85 _COMMON       Control the common area
$FF86 _RENAME       Rename files or directories and move files
$FF87 _FILEDATE     Get or set the date and time of a file
$FF88 _MALLOC2      Allocate a memory block (mode specified)
$FF8A _MAKETMP      Create a temporary file
$FF8B _NEWFILE      Create a new file (non-destructive)
$FF8C _LOCK         Control the locking of a handler
$FF8F _ASSIGN       Get and set virtual drives and directories
------------------------------------------------------------------
$FFAA _FFLUSMD      Get or set the mode of _FFLUSH
$FFAB _OS_PATCH     Patch Human
$FFAC _GETFCB       Get FCB Table
$FFAD _S_MALLOC     Allocate a block of memory from the main thread's memory management
$FFAE _S_MFREE      Release a memory block from the main thread's memory management
$FFAF _S_PROCESS    Set the sub-memory management for the specified thread
------------------------------------------------------------------
$FFF3 _DISKRED      Read directly from a device
$FFF4 _DISKWRT      Write directly to a device
$FFF5 _INDOSFLG     Acquire Human work area
$FFF6 _SUPER_JSR    Call a subroutine in supervisor mode
$FFF7 _BUS_ERR      Bus error check
$FFF8 _OPEN_PR      Create a new thread
$FFF9 _KILL_PR      Killing a running thread
$FFFA _GET_PR       Get the thread management table for the specified thread number
$FFFB _SUSPEND_PR   Force the specified thread to sleep
$FFFC _SLEEP_PR     Put the running thread to sleep
$FFFD _SEND_PR      Wake up a thread
$FFFE _TIME_PR      Get the current timer counter value
$FFFF _CHANGE_PR    Switch to the next thread
------------------------------------------------------------------


DOS Call list (by call name)
------------------------------------------------------------------
Number Call name    Function overview
------------------------------------------------------------------
$FF1F _ALLCLOSE     Close all handlers opened by the running process and its child processes
$FF8F _ASSIGN       Get and set virtual drives and directories
------------------------------------------------------------------
$FF33 _BREAKCK      Get or set break and off
$FFF7 _BUS_ERR      Bus error check
------------------------------------------------------------------
$FFFF _CHANGE_PR    Switch to the next thread
$FF3B _CHDIR        Set the current directory
$FF0E _CHGDRV       Change the current drive
$FF43 _CHMOD        Read or set attributes of a file or directory
$FF12 _CINSNS       Check whether input from standard serial I/O is possible
$FF3E _CLOSE        Close a Handler
$FF03 _COMINP       Read one byte from standard serial I/O
$FF85 _COMMON       Control the common area
$FF04 _COMOUT       Output one byte to standard serial I/O
$FF23 _CONCTRL      Console output control
$FF10 _CONSNS       Check whether output to standard output is possible
$FF13 _COUTSNS      Check whether output to standard serial input/output is possible
$FF3C _CREATE       Create a new file
$FF47 _CURDIR       Get the current directory
$FF19 _CURDRV       Get the current drive number
------------------------------------------------------------------
$FF41 _DELETE       Delete file
$FFF3 _DISKRED      Read directly from a device
$FFF4 _DISKWRT      Write directly to a device
$FF0F _DRVCTRL      Drive control
$FF34 _DRVXCHG      Swap drive numbers
$FF36 _DSKFRE       Gets the free space on the specified drive
$FF45 _DUP          Duplicate a Handler
$FF2F _DUP0         Convert a standard handler
$FF46 _DUP2         Duplicate a Handler
------------------------------------------------------------------
$FF4B _EXEC         Run a child process
$FF00 _EXIT         Process termination (no exit code specified)
$FF4C _EXIT2        Process termination (with exit code specified)
------------------------------------------------------------------
$FF17 _FATCHK       Check the FAT connections of files and directories
$FF0D _FFLUSH       Buffer Flush
$FFAA _FFLUSMD      Get or set the mode of _FFLUSH
$FF1B _FGETC        Read one byte from the specified handler
$FF1C _FGETS        Read a string from the specified handler
$FF87 _FILEDATE     Get or set the date and time of a file
$FF4E _FILES        Directory entry search (first)
$FF21 _FNCKEY       Read and set redefinable keys
$FF1D _FPUTC        Output one byte to the specified handler
$FF1E _FPUTS        Output a string to the specified handler
------------------------------------------------------------------
$FF08 _GETC         Read one byte from standard input (processes ^C, ^P, ^N)
$FF01 _GETCHAR      Read one byte from standard input (echoed back to standard output)
$FF2A _GETDATE      Get the date
$FF32 _GETDPB       Gets the DPB table for the specified drive.
$FF83 _GETENV       Get an environment variable
$FFAC _GETFCB       Get FCB Table
$FF81 _GETPDB       Get the process management table
$FF0A _GETS         Read a string from standard input (processes ^C, ^P, ^N)
$FF1A _GETSS        Read a string from standard input (does not process ^C, ^P, ^N)
$FF27 _GETTIM2      Get the time (long word)
$FF2C _GETTIME      Get the time (word)
$FFFA _GET_PR       Get the thread management table for the specified thread number
------------------------------------------------------------------
$FF18 _HENDSP       Kana-Kanji conversion window control
------------------------------------------------------------------
$FFF5 _INDOSFLG     Acquire Human work area
$FF07 _INKEY        Read one byte from standard input (does not process ^C, ^P, ^N)
$FF06 _INPOUT       Standard I/O handler input/output
$FF35 _INTVCG       Get an exception vector
$FF25 _INTVCS       Set an exception handling vector
$FF44 _IOCTRL       Direct control of a handler by the device
------------------------------------------------------------------
$FF31 _KEEPPR       Terminate the currently running process
$FF24 _KEYCTRL      Console input control
$FF0B _KEYSNS       Read one byte ahead from standard input
$FF0C _KFLUSH       Flush the standard input buffer and then read from standard input.
$FFF9 _KILL_PR      Killing a running thread
$FF22 _KNJCTRL      Kana-Kanji conversion control
------------------------------------------------------------------
$FF8C _LOCK         Control the locking of a handler
------------------------------------------------------------------
$FF8A _MAKETMP      Create a temporary file
$FF48 _MALLOC       Allocate a memory block (from the bottom)
$FF88 _MALLOC2      Allocate a memory block (mode specified)
$FF49 _MFREE        Free a memory block
$FF39 _MKDIR        Create a Directory
------------------------------------------------------------------
$FF37 _NAMECK       File name check
$FF29 _NAMESTS      Filename decomposition
$FF8B _NEWFILE      Create a new file (non-destructive)
$FF4F _NFILES       Searching for directory entries (next)
------------------------------------------------------------------
$FF3D _OPEN         Open a Handler
$FFF8 _OPEN_PR      Create a new thread
$FFAB _OS_PATCH     Patch Human
------------------------------------------------------------------
$FF09 _PRINT        Output a string to standard output
$FF05 _PRNOUT       Output one byte to the standard printer output
$FF11 _PRNSNS       Check whether output to a standard printer is possible
$FF26 _PSPSET       Create a process management table
$FF02 _PUTCHAR      Output one byte to standard output
------------------------------------------------------------------
$FF3F _READ         Read the specified size of data from a handler
$FF86 _RENAME       Rename files or directories and move files
$FF3A _RMDIR        Delete a Directory
------------------------------------------------------------------
$FF42 _SEEK         Change the seek position of a handler
$FFFD _SEND_PR      Wake up a thread
$FF4A _SETBLOCK     Change the size of a memory block
$FF2B _SETDATE      Set the date
$FF82 _SETENV       Set an environment variable
$FF80 _SETPDB       Move the process management table
$FF28 _SETTIM2      Set the time (long word)
$FF2D _SETTIME      Set the time (word)
$FFFC _SLEEP_PR     Put the running thread to sleep
$FF20 _SUPER        Switch between processor modes
$FFF6 _SUPER_JSR    Call a subroutine in supervisor mode
$FFFB _SUSPEND_PR   Force the specified thread to sleep
$FFAD _S_MALLOC     Allocate a block of memory from the main thread's memory management
$FFAE _S_MFREE      Release a memory block from the main thread's memory management
$FFAF _S_PROCESS    Set the sub-memory management for the specified thread
------------------------------------------------------------------
$FFFE _TIME_PR      Get the current timer counter value
------------------------------------------------------------------
$FF2E _VERIFY       Set verify mode
$FF84 _VERIFYG      Get the verify mode
$FF30 _VERNUM       Get Human version
------------------------------------------------------------------
$FF4D _WAIT         Get the exit code of a child process
$FF40 _WRITE        Write the specified size of data to a handler
------------------------------------------------------------------


------------------------------------------------------------------
References

Programmer's Manual, 
Sharp X68000 Data Book, POPCOM Editorial Department, Shogakukan


------------------------------------------------------------------
(EOF)
